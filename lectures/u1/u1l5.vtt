WEBVTT

1
00:00:02.160 --> 00:00:08.310
In the previous unit, we learned how
to implement the gate logic using HDL.

2
00:00:09.610 --> 00:00:13.130
However, nothing in what we did

3
00:00:13.130 --> 00:00:18.510
guarantees that the HDL code that
we wrote is actually correct.

4
00:00:18.510 --> 00:00:23.070
We have no idea if this architecture
that we put together delivers

5
00:00:23.070 --> 00:00:29.240
the intended results of the chip
that we seek to design.

6
00:00:29.240 --> 00:00:34.270
So in this unit, we will close this
gap and we will learn how we can take

7
00:00:34.270 --> 00:00:40.920
an HDL program and verify to the best
of our ability that the program or

8
00:00:40.920 --> 00:00:46.280
the HDL file delivers the intended
functionality of the underlying chip.

9
00:00:47.780 --> 00:00:51.680
Now here is the big picture
of what we're going to do.

10
00:00:53.090 --> 00:00:57.890
Given that we have a particular
HDL file and we want to test it,

11
00:00:57.890 --> 00:01:03.700
we can load it into a special
program called hardware simulator.

12
00:01:05.260 --> 00:01:11.290
We have written such program and
made it available to you, in our website.

13
00:01:11.290 --> 00:01:15.600
This program happens to to
to be written in, in Java.

14
00:01:15.600 --> 00:01:21.270
And this program is designed to
simulate and test HDL files.

15
00:01:21.270 --> 00:01:24.550
So we load it into this program.

16
00:01:24.550 --> 00:01:29.940
We interactively test all sorts
of operations in this chip and

17
00:01:29.940 --> 00:01:34.000
we call this mode of testing
interactive simulation.

18
00:01:34.000 --> 00:01:39.950
Alternatively we can
write another file and

19
00:01:40.980 --> 00:01:45.590
using a special language that we designed,
which we call the testing language,

20
00:01:45.590 --> 00:01:49.030
something that you can
learn in a few minutes.

21
00:01:49.030 --> 00:01:56.510
We can put together a set of replicable
tests that are predetermined.

22
00:01:56.510 --> 00:01:58.550
So we don't have to do
things interactively.

23
00:01:58.550 --> 00:02:04.630
We can think ahead of how we can
systematically test the underlying chip.

24
00:02:04.630 --> 00:02:08.530
We write in what is
called a test script and

25
00:02:08.530 --> 00:02:11.510
then we load into the simulator
two separate files.

26
00:02:11.510 --> 00:02:13.100
We load the HDL code.

27
00:02:13.100 --> 00:02:17.990
We load the test script and
then we send the simulator to work.

28
00:02:17.990 --> 00:02:23.630
The simulator goes through every
step in the test script and subjects

29
00:02:23.630 --> 00:02:31.180
the HDL code to the to the specified
tests in this supplied script.

30
00:02:31.180 --> 00:02:35.230
We call this mode of operation
script-based simulation.

31
00:02:36.330 --> 00:02:40.490
And finally, if we want, we can record

32
00:02:40.490 --> 00:02:45.050
the output of the simulation on
something called an output file.

33
00:02:45.050 --> 00:02:50.580
And we can even compare the results of
the simulation to a desired output,

34
00:02:50.580 --> 00:02:54.250
which is stored in, in yet
another file called compare file.

35
00:02:55.700 --> 00:03:00.400
So as you see,
there are many new concepts and

36
00:03:00.400 --> 00:03:04.610
techniques involved in this
practice of hardware simulation.

37
00:03:05.670 --> 00:03:09.200
And the purpose of this unit is to make,
you know,

38
00:03:09.200 --> 00:03:14.547
all this new information concrete by
walking you through a step-by-step

39
00:03:14.547 --> 00:03:21.170
process of testing a working example that
will accompany us throughout this unit.

40
00:03:22.240 --> 00:03:28.030
Now, throughout this unit, we are going
to present several software tools.

41
00:03:28.030 --> 00:03:29.380
Actually only one software tool,

42
00:03:29.380 --> 00:03:35.230
the hardware simulator, and you are more
than welcome to stop the video.

43
00:03:35.230 --> 00:03:39.360
Invoke this hardware simulator
on your own computer and

44
00:03:39.360 --> 00:03:44.560
make sure that what we do can
be done also on your machine.

45
00:03:44.560 --> 00:03:48.890
You can do all of this if you have
downloaded the software suite at

46
00:03:48.890 --> 00:03:52.160
the beginning of the course and if so,

47
00:03:52.160 --> 00:03:55.580
the hardware simulator should
be available on your computer.

48
00:03:55.580 --> 00:04:00.420
And everything that we do in the lecture
can be done by by you as well.

49
00:04:00.420 --> 00:04:06.640
So we encourage you to kick
tires as much as you please.

50
00:04:06.640 --> 00:04:11.700
So let's go on and and start with
the with some concrete examples.

51
00:04:13.120 --> 00:04:17.370
So here's the example that I'm
going to use throughout this unit.

52
00:04:17.370 --> 00:04:23.140
It's an HDL file describing
the score chip that we talked about

53
00:04:23.140 --> 00:04:29.450
in the previous unit so the code itself
should be familiar to you even though

54
00:04:29.450 --> 00:04:36.080
it's not terribly important for
understanding this particular unit.

55
00:04:36.080 --> 00:04:36.870
All right.

56
00:04:36.870 --> 00:04:41.810
So once again the fact that we
wrote this very nice piece of code

57
00:04:41.810 --> 00:04:45.390
does not imply in any way that
the code is actually correct.

58
00:04:45.390 --> 00:04:49.390
In fact most likely it contains some
errors, either syntax errors or

59
00:04:49.390 --> 00:04:51.490
logical errors or, or whatnot.

60
00:04:51.490 --> 00:04:53.170
So how do we test it?

61
00:04:53.170 --> 00:04:55.120
Well, here's what we can do.

62
00:04:55.120 --> 00:04:59.250
We can invoke the hardware simulator.

63
00:04:59.250 --> 00:05:01.020
Program starts running.

64
00:05:01.020 --> 00:05:06.130
We can load the HDL file
into this simulator and

65
00:05:06.130 --> 00:05:10.910
we can then enter zeroes and
ones into the a and

66
00:05:10.910 --> 00:05:16.440
b inputs and
observe what is going on inside the chip.

67
00:05:16.440 --> 00:05:19.000
Now, how do we observe what is going on?

68
00:05:19.000 --> 00:05:24.400
Well, we have to tell the simulator
to evaluate the chip's logic.

69
00:05:24.400 --> 00:05:28.340
The simulator will not do anything
until we, we tell it to actually

70
00:05:29.470 --> 00:05:33.300
consider the new inputs that we
entered and evaluate the chip's logic.

71
00:05:33.300 --> 00:05:37.900
And if we do this, the simulator will take
these values, these zeroes and ones, or

72
00:05:37.900 --> 00:05:44.190
whatever we entered, and will kind of
pipe them through the architecture.

73
00:05:44.190 --> 00:05:51.300
And at some point, something will come out
from the from the output pin of the chip,

74
00:05:51.300 --> 00:05:56.260
so at that point,
we can inspect what actually materialized.

75
00:05:56.260 --> 00:05:59.900
So we can observe
the outputs of the chip and

76
00:05:59.900 --> 00:06:04.310
in this particular case,
the value of the out pin and

77
00:06:04.310 --> 00:06:09.650
if we want, we can also inspect
the values of the internal pins.

78
00:06:09.650 --> 00:06:13.030
Pins like not b, not a and so on,

79
00:06:13.030 --> 00:06:18.770
and the simulator gives us all
these all these nice capabilities.

80
00:06:18.770 --> 00:06:21.205
In particular, here's an example or

81
00:06:21.205 --> 00:06:26.920
screenshot of the hardware
simulator in action and

82
00:06:26.920 --> 00:06:32.200
the simulator contains features,
several different panes.

83
00:06:32.200 --> 00:06:36.630
So, let's talk about each one
of these panes in isolation.

84
00:06:36.630 --> 00:06:40.660
First of all,
at the bottom-left of the screen,

85
00:06:40.660 --> 00:06:45.550
we see the HDL code that we
have loaded into the simulator.

86
00:06:45.550 --> 00:06:47.780
This is a static view.

87
00:06:47.780 --> 00:06:50.880
We cannot manipulate or edit this code.

88
00:06:50.880 --> 00:06:55.460
If we want to edit anything,
we have to use an external text editor,

89
00:06:55.460 --> 00:06:58.540
change the HDL code and reload it.

90
00:06:58.540 --> 00:07:02.450
So this pane you know,
gives us an idea of what is it,

91
00:07:02.450 --> 00:07:06.430
what is it exactly that we
loaded into the simulator.

92
00:07:07.480 --> 00:07:13.060
Here we can actually interact with
the input panes of the simulator.

93
00:07:13.060 --> 00:07:16.550
We can click them and change the values.

94
00:07:16.550 --> 00:07:18.820
We have four different
possibilities of zeroes and

95
00:07:18.820 --> 00:07:21.090
ones in, in this particular example.

96
00:07:21.090 --> 00:07:23.180
Now this is very simple chip.

97
00:07:23.180 --> 00:07:27.160
And once we do this,
we can click this icon.

98
00:07:27.160 --> 00:07:32.670
Which looks like a calculator, and once we
click it, we basically tell the simulator

99
00:07:32.670 --> 00:07:37.500
to evaluate the chip's logic
on the supplied inputs.

100
00:07:37.500 --> 00:07:40.780
At this point the simulator
will spin its wheels.

101
00:07:40.780 --> 00:07:45.330
It will take a fraction of a second and
something will come out.

102
00:07:45.330 --> 00:07:49.000
We can then evaluate
the output of the chip.

103
00:07:49.000 --> 00:07:52.545
In this particular case we have
only one output called out.

104
00:07:52.545 --> 00:07:56.483
And once again if we
want we can also inspect

105
00:07:56.483 --> 00:08:00.254
the the current values
of the internal pins.

106
00:08:00.254 --> 00:08:03.712
So altogether this GUI gives
us everything that we need.

107
00:08:03.712 --> 00:08:09.286
In order to carry out sort of hands on
interactive simulation of of exalt chip or

108
00:08:09.286 --> 00:08:12.260
any other chip for this matter.

109
00:08:12.260 --> 00:08:16.780
All right,
moving along I would like now to give you

110
00:08:16.780 --> 00:08:21.450
actually a hands on example of of
the hardware simulator in action.

111
00:08:21.450 --> 00:08:24.500
So let's do that and
then go back to the to the lecture.

112
00:08:25.850 --> 00:08:28.220
This is the hardware simulator.

113
00:08:28.220 --> 00:08:32.150
And, in order to use it,
we have to first of all,

114
00:08:32.150 --> 00:08:36.260
load an HDL program into the simulator.

115
00:08:36.260 --> 00:08:39.900
And, we do it by clicking this icon here.

116
00:08:39.900 --> 00:08:41.660
So, let us do it.

117
00:08:41.660 --> 00:08:46.430
And, we see that we are in
the nand2tetris folder,

118
00:08:46.430 --> 00:08:50.640
so within this folder,
we're going to select Projects.

119
00:08:50.640 --> 00:08:53.185
And within Projects,
we'll select Project 0.

120
00:08:54.360 --> 00:09:00.110
And we see that we have a single
HDL file here, so let us select it.

121
00:09:00.110 --> 00:09:02.850
This is Xor file that we discussed before.

122
00:09:04.160 --> 00:09:07.585
And we loaded the chip into the simulator.

123
00:09:07.585 --> 00:09:13.400
[COUGH] Now the pane at the bottom left,
right here

124
00:09:13.400 --> 00:09:18.890
gives me a display of
the file that I just loaded.

125
00:09:18.890 --> 00:09:21.240
I can scroll back and forth.

126
00:09:21.240 --> 00:09:26.560
It's not separate,
it's not terribly useful but

127
00:09:26.560 --> 00:09:30.550
this pane is actually
just a read only display.

128
00:09:30.550 --> 00:09:35.700
There's no way to actually change the code
when you are inside the simulator.

129
00:09:35.700 --> 00:09:41.150
If you want to change the code, you have
to do it using an external text editor and

130
00:09:41.150 --> 00:09:48.089
then you have to reload, of course, the
file that you changed and saved elsewhere.

131
00:09:48.089 --> 00:09:52.040
So, let us assume that we
are happy with this file and

132
00:09:52.040 --> 00:09:55.610
I want to actually
simulate the chip logic.

133
00:09:55.610 --> 00:10:00.700
Well I do this by first of all looking
at the current input values and

134
00:10:00.700 --> 00:10:07.580
we see that the default values of the a
and b inputs of Xor chip happen to be 0.

135
00:10:07.580 --> 00:10:11.380
So if I want, I can go ahead and
change one of them,

136
00:10:11.380 --> 00:10:13.530
or both of them to some other values.

137
00:10:13.530 --> 00:10:19.400
So let us change A to 1 and let us
change and let us also change b to one.

138
00:10:19.400 --> 00:10:23.070
And I noticed that nothing yet

139
00:10:23.070 --> 00:10:28.150
happened in order to, to see how
the chip responds to these changes.

140
00:10:28.150 --> 00:10:31.229
I have to reevaluate the chip logic and
I do it by.

141
00:10:32.270 --> 00:10:35.270
By clicking this icon here,
the calculator icon.

142
00:10:35.270 --> 00:10:42.821
So let us do it and we see that once we
click this icon, the output becomes 0.

143
00:10:43.980 --> 00:10:49.440
And [COUGH] indeed Xor of 1 and one is 1.

144
00:10:49.440 --> 00:10:51.340
If you want to see some
other possibilities,

145
00:10:51.340 --> 00:10:55.840
we can once again manipulate
one of the input panes.

146
00:10:55.840 --> 00:11:02.070
Click the calculator, and
we see that Xor now emits, 1 instead of 0.

147
00:11:03.210 --> 00:11:08.320
Another thing that we can do is,
inspect the values

148
00:11:08.320 --> 00:11:14.080
of the internal pins which gives us yet
another level of

149
00:11:14.080 --> 00:11:18.870
scrutiny in particular when we,
when we try to debug the chip and

150
00:11:18.870 --> 00:11:24.620
understand why it is misbehaving for
some reason.

151
00:11:24.620 --> 00:11:29.750
So this has been a very brief description
of the first thing that we do when

152
00:11:29.750 --> 00:11:35.220
you use a simulator, you load the chip,
you play with the input panes,

153
00:11:35.220 --> 00:11:38.950
you inspect the outputs and
the internal pins, and and

154
00:11:38.950 --> 00:11:44.400
this is the ABC of of chip debugging and
testing.

155
00:11:44.400 --> 00:11:49.830
I wish to remind you in closing that
if you want to change the chip logic,.

156
00:11:49.830 --> 00:11:55.600
You have to edit the HDL file
using some external text editor.

157
00:11:55.600 --> 00:12:00.240
Save the new file,
reload it into the simulator and

158
00:12:00.240 --> 00:12:04.580
rerun the tests in order to
test the new chip design.

159
00:12:05.780 --> 00:12:10.380
Now, interactive simulation is,
is very nice indeed, but

160
00:12:10.380 --> 00:12:16.610
at some point it can become rather
tedious, especially if you have you know,

161
00:12:16.610 --> 00:12:21.780
lots of bugs in your design and
and each time you have to,

162
00:12:21.780 --> 00:12:25.320
you know, go through the same set
of tests and so on and so forth.

163
00:12:25.320 --> 00:12:27.220
So, with that in mind.

164
00:12:27.220 --> 00:12:34.830
We are fortunate that we also have the
notion of a test script available to us.

165
00:12:34.830 --> 00:12:38.310
So here once again is the tested chip.

166
00:12:38.310 --> 00:12:42.230
And by the way,
I allow myself to use the words chip and

167
00:12:42.230 --> 00:12:49.580
gate interchangeably for me,
a gate is simply a, a simple chip.

168
00:12:49.580 --> 00:12:51.700
So this is the tested chip.

169
00:12:51.700 --> 00:13:00.640
And here is an example of a test
script designed to test a Xor gate.

170
00:13:00.640 --> 00:13:05.780
Now let us go through the test
script kind of line by line.

171
00:13:05.780 --> 00:13:10.450
The first command in the test
script instruct the simulator

172
00:13:10.450 --> 00:13:14.840
to load the Xor.hdl file into the program.

173
00:13:14.840 --> 00:13:17.920
So even this step is, is taken care of.

174
00:13:17.920 --> 00:13:19.480
We don't have to do it ourselves.

175
00:13:19.480 --> 00:13:22.950
The test script will,
will load the program for us.

176
00:13:22.950 --> 00:13:26.850
By the way, this is terribly important
if you do repetitive debugging,

177
00:13:26.850 --> 00:13:29.160
because how do you debug a gate?

178
00:13:29.160 --> 00:13:33.300
You use an external text editor you know,
to change the gate, and then you,

179
00:13:33.300 --> 00:13:36.810
you click Save, and
you go back to the simulator.

180
00:13:36.810 --> 00:13:42.040
So, it's important to remember to reload
the new version of the edited chips.

181
00:13:42.040 --> 00:13:45.850
So, that's why we added this command
that to, to the test script.

182
00:13:45.850 --> 00:13:51.610
Now, once the test once the hdl
is loaded into the simulator,

183
00:13:51.610 --> 00:13:57.020
the test grid begins
a process of subjecting

184
00:13:57.020 --> 00:14:01.920
the chip to to four different tests.

185
00:14:01.920 --> 00:14:06.280
The semicolon represents you know,

186
00:14:06.280 --> 00:14:09.268
the ending of of one
particular test if you will.

187
00:14:09.268 --> 00:14:13.569
And so, we set the input

188
00:14:13.569 --> 00:14:18.630
values of the chip to 0 and 0.

189
00:14:18.630 --> 00:14:22.780
We evaluate the chip logic and

190
00:14:22.780 --> 00:14:27.580
observe the results and
then we go through the next test and

191
00:14:27.580 --> 00:14:32.400
and so on and so forth until we
complete all the possible all,

192
00:14:32.400 --> 00:14:36.280
all the input possibilities for
this particular chip.

193
00:14:36.280 --> 00:14:41.980
So this is how we carry out script ba,
script-based testing.

194
00:14:41.980 --> 00:14:43.588
And it has many benefits.

195
00:14:43.588 --> 00:14:48.970
And far and foremost is the fact
that we don't have to do anything

196
00:14:50.590 --> 00:14:59.090
laboriously, you know,
using our own sort of intuition.

197
00:14:59.090 --> 00:15:00.590
Because everything is pre-determined.

198
00:15:00.590 --> 00:15:05.190
We have a set of rep,
replicable tests and we just.

199
00:15:05.190 --> 00:15:08.290
Use the same tests over and
over whenever we

200
00:15:08.290 --> 00:15:12.340
we debug the chip which can be you know,
two weeks or two months from now.

201
00:15:12.340 --> 00:15:15.480
So it's good to know that you can
always repeat the same set of tests.

202
00:15:16.595 --> 00:15:22.410
So, altogether,
we will try to always use a test script.

203
00:15:22.410 --> 00:15:26.040
And the good news is that you don't really
have to worry about how to write test

204
00:15:26.040 --> 00:15:31.440
scripts because we are going to supply to
you all the test scripts that you need

205
00:15:31.440 --> 00:15:36.760
in order to test the the chips that,
that you are going to design in hdl.

206
00:15:36.760 --> 00:15:39.220
So you worry about the hdl and

207
00:15:39.220 --> 00:15:42.860
we are going to worry about
the the testing of of your work.

208
00:15:44.700 --> 00:15:51.300
Another thing that we can do is keep
track of the outputs of the simulation.

209
00:15:51.300 --> 00:15:54.622
So in particular we can augment our basic

210
00:15:54.622 --> 00:15:59.841
test scripts with something
like the following commands.

211
00:15:59.841 --> 00:16:05.923
We can at the beginning of the of the test
when we initialize things, we can.

212
00:16:05.923 --> 00:16:10.345
Instruct the simulator to
create an output file,

213
00:16:10.345 --> 00:16:15.410
which in this example,
we happen to call Xor.out.

214
00:16:15.410 --> 00:16:20.041
And as we go through
the through the testing.

215
00:16:20.041 --> 00:16:22.054
At the end of each test,

216
00:16:22.054 --> 00:16:27.594
we tell the simulator to output to
the output file a set of values,

217
00:16:27.594 --> 00:16:32.350
which is determined in
the preamble of the script.

218
00:16:32.350 --> 00:16:37.990
So, as you see the third line with script
says, the output placed is a, b, and out.

219
00:16:37.990 --> 00:16:42.975
And so whenever the simulator
would see the directive output,

220
00:16:42.975 --> 00:16:48.441
it will write to the output file,
the current values of a, b and out.

221
00:16:48.441 --> 00:16:50.801
And at the end of the simulation,

222
00:16:50.801 --> 00:16:56.869
we can simply inspect the result of
the output file and convince our self that

223
00:16:56.869 --> 00:17:01.790
the chip has actually behaved
according to expectations.

224
00:17:01.790 --> 00:17:04.571
In fact, in this particular example,

225
00:17:04.571 --> 00:17:10.218
if you will inspect the output file
that emerged from the simulation,

226
00:17:10.218 --> 00:17:16.490
you will notice that it is completely
identical to the truth table of Xor gate.

227
00:17:16.490 --> 00:17:21.130
So it looks like the gate
is well behaving.

228
00:17:21.130 --> 00:17:25.034
So here's a snapshot of the hardware

229
00:17:25.034 --> 00:17:29.950
simulation in action using a test script.

230
00:17:29.950 --> 00:17:32.678
And once again, we have the HDL code as,

231
00:17:32.678 --> 00:17:36.630
as we did before at the bottom left of,
of the screen.

232
00:17:36.630 --> 00:17:38.790
But we, but we now have something new.

233
00:17:38.790 --> 00:17:44.460
We have a test script,
which can be seen on the right pane.

234
00:17:44.460 --> 00:17:47.855
Which is some sort of
a multipurpose GUI area,

235
00:17:47.855 --> 00:17:51.610
which we use for for different purposes.

236
00:17:51.610 --> 00:17:54.037
And after we load the script,

237
00:17:54.037 --> 00:17:58.490
we can instruct the simulator
to actually execute the script.

238
00:17:58.490 --> 00:18:05.490
We do it by clicking this control and
the simulator the simulator goes to work.

239
00:18:05.490 --> 00:18:12.001
And at the end, if we want,
we can inspect the resulting output file.

240
00:18:12.001 --> 00:18:17.185
And here is also a demo of
of the same thing with,

241
00:18:17.185 --> 00:18:21.630
with an actual how do simulations session.

242
00:18:21.630 --> 00:18:26.533
We will now show how to use
the how to simulator in

243
00:18:26.533 --> 00:18:31.110
order to test an HDL program
using a test script.

244
00:18:31.110 --> 00:18:38.030
So the first thing that we can do is
load the HDL program into the simulator.

245
00:18:38.030 --> 00:18:43.593
So let us choose the same Xor.hdl
chip that we used before and

246
00:18:43.593 --> 00:18:49.170
then instead of playing with
the input pins interactively.

247
00:18:49.170 --> 00:18:54.152
We can use this icon here
to open a test script and

248
00:18:54.152 --> 00:18:57.889
we see that in the project zero folder,

249
00:18:57.889 --> 00:19:02.770
we have one test script called Xor.tst.

250
00:19:02.770 --> 00:19:07.381
So let us load it into
the simulator environment.

251
00:19:07.381 --> 00:19:12.463
Once we do it this pane in
the interface shows us the contents of

252
00:19:12.463 --> 00:19:18.430
the currently loaded test script and
we see that it begins with a few comments.

253
00:19:18.430 --> 00:19:23.010
And then following that,
we see the actual testing commands.

254
00:19:23.010 --> 00:19:27.873
And the first command or
the next command to be executed,

255
00:19:27.873 --> 00:19:31.011
is highlighted by a yellow bar,

256
00:19:31.011 --> 00:19:35.690
we can call it the cursor
of the of the test script.

257
00:19:35.690 --> 00:19:41.416
Now we see that each command
ends either with a comma or

258
00:19:41.416 --> 00:19:46.124
a semicolon and
when we click the play icon,

259
00:19:46.124 --> 00:19:51.342
the simulator is going to
execute all the testing

260
00:19:51.342 --> 00:19:56.960
commands until the next
semicolon is encountered.

261
00:19:56.960 --> 00:20:02.921
Now the first four commands in this test
strip set up the simulation so to speak.

262
00:20:02.921 --> 00:20:06.650
And so let us, let us execute them.

263
00:20:06.650 --> 00:20:08.790
So I click this icon here.

264
00:20:08.790 --> 00:20:13.850
And we see that the cursor moved
to the next batch of commands.

265
00:20:13.850 --> 00:20:19.090
And this batch says,
set a to 0, set b to 0.

266
00:20:19.090 --> 00:20:22.750
These are the input pins
of this particular chip.

267
00:20:22.750 --> 00:20:30.130
And then evaluate the chip logic and
output the result into the output file.

268
00:20:30.130 --> 00:20:35.229
So let us execute this
batch of commands and

269
00:20:35.229 --> 00:20:41.090
we see that indeed, the a and
b inputs are now 0 and

270
00:20:41.090 --> 00:20:47.610
the out of the chip happens to be 0,
which seems to be right.

271
00:20:47.610 --> 00:20:53.061
Because as we know, Xor of and
zero and zero should be zero.

272
00:20:53.061 --> 00:20:57.866
So let us execute the next
batch of test script commands.

273
00:20:57.866 --> 00:21:03.124
This batch sets a to 0 and
b to 1, evaluates the shapes and

274
00:21:03.124 --> 00:21:08.482
outputs the result and indeed,
we see that Xor of 0 and

275
00:21:08.482 --> 00:21:12.936
0 ended up being 1,
which seems to be correct.

276
00:21:12.936 --> 00:21:17.970
So executing the next batch of
commands sets a to 0, I'm sorry.

277
00:21:17.970 --> 00:21:24.530
Sets a to 1 and b to 0 giving the result
1, which also seems to be correct.

278
00:21:24.530 --> 00:21:28.154
And then moving along,
we execute the next and

279
00:21:28.154 --> 00:21:32.050
final batch of commands,
which set both a and b to one.

280
00:21:32.050 --> 00:21:37.187
And we see that the Xor response
by emitting the value zero,

281
00:21:37.187 --> 00:21:41.010
which once again seems to be correct.

282
00:21:41.010 --> 00:21:46.076
Now the test script for
Xor gate is relatively simple,

283
00:21:46.076 --> 00:21:52.246
because basically,
it simply executes every possible input

284
00:21:52.246 --> 00:21:57.550
combination as stated by
the chip truth table.

285
00:21:57.550 --> 00:22:02.610
In more complex shapes such an exhaustive
testing is is less feasible.

286
00:22:02.610 --> 00:22:08.310
And therefore, the test, testing
scripts will likely be more complex.

287
00:22:08.310 --> 00:22:13.906
Now, as we tested this script
the script has also written

288
00:22:13.906 --> 00:22:20.270
the results of every test script
batch into the output file.

289
00:22:20.270 --> 00:22:25.990
You know, this is the the result of
saying output in, in the I'm sorry.

290
00:22:25.990 --> 00:22:28.850
This is the result of,
of the output command.

291
00:22:28.850 --> 00:22:32.837
Now, if we want to inspect
the output file, we can do so

292
00:22:32.837 --> 00:22:37.370
by going to this control here and
selecting Output.

293
00:22:37.370 --> 00:22:39.050
So let's do that.

294
00:22:39.050 --> 00:22:43.770
And once we do it,
we see that the output file,

295
00:22:43.770 --> 00:22:49.603
indeed looks exactly, like the truth
table of Xor and this gives us yet

296
00:22:49.603 --> 00:22:55.270
another indication that the chip
has operated to a specification.

297
00:22:55.270 --> 00:22:59.510
Before we go on with this
step by step working example,

298
00:22:59.510 --> 00:23:02.804
I would like to stop for
a minute or two and

299
00:23:02.804 --> 00:23:08.470
say some general things about the general
concept of hardware simulators.

300
00:23:08.470 --> 00:23:10.930
So first of all, there are many of them.

301
00:23:10.930 --> 00:23:14.310
Some of them are free and open source.

302
00:23:14.310 --> 00:23:20.190
Others are proprietary and
very sophisticated and very expensive.

303
00:23:20.190 --> 00:23:25.122
And in this course, we use a simple
hardware simulator, which at the same

304
00:23:25.122 --> 00:23:30.131
time, gives you everything that you need
in order to build the head computer and

305
00:23:30.131 --> 00:23:34.318
any other computer that you want
to build using the techniques

306
00:23:34.318 --> 00:23:36.310
described in the course.

307
00:23:36.310 --> 00:23:43.049
So the supplied hardware simulator,
which you have on your computer now is a,

308
00:23:43.049 --> 00:23:47.530
is a tool that once again,
gives you everything you need.

309
00:23:47.530 --> 00:23:50.457
And if you want to learn how to use it,

310
00:23:50.457 --> 00:23:56.379
there are several places to consult
with available documentation.

311
00:23:56.379 --> 00:24:02.704
If you go to the nand2tetris .org
website you can find a full chapter,

312
00:24:02.704 --> 00:24:08.295
I think it's appendix a and appen,
actually appendix and appendix b.

313
00:24:08.295 --> 00:24:12.837
In our book describe how to
use the hardware simulator and

314
00:24:12.837 --> 00:24:17.458
these, these chapters are also
available freely on the website and

315
00:24:17.458 --> 00:24:22.307
another thing that you should do is go for
the hardware simulator tutorial,

316
00:24:22.307 --> 00:24:28.288
which is a stack of interacting slides
that that explain how to use the simulator

317
00:24:28.288 --> 00:24:32.805
as well as all of the examples that
you saw in this particular lecture.

318
00:24:32.805 --> 00:24:38.743
So that's the end of of the commercial
break about hardware simulators and

319
00:24:38.743 --> 00:24:41.512
we return to our ongoing example.

320
00:24:41.512 --> 00:24:45.112
So let us revisit what we have done so
far.

321
00:24:45.112 --> 00:24:49.915
We looked at a particular HDL file,

322
00:24:49.915 --> 00:24:54.189
which records the logic of Xor.

323
00:24:54.189 --> 00:24:58.401
We have supplied the simulator with

324
00:24:58.401 --> 00:25:03.269
a test script designed to
test this particular code.

325
00:25:03.269 --> 00:25:07.955
And we also looked at
the resulting output file and

326
00:25:07.955 --> 00:25:13.322
convinced ourself that the HDL
file is actually correct.

327
00:25:13.322 --> 00:25:18.452
Now this privilege of looking at
an output file and saying, yeah,

328
00:25:18.452 --> 00:25:24.200
it works is something which is rarely
available in real life testing.

329
00:25:24.200 --> 00:25:25.129
Why?

330
00:25:25.129 --> 00:25:31.270
Because the chips that we normally build
are far more complex than Xor gate.

331
00:25:31.270 --> 00:25:36.125
And there is no way to look
at an output file of let's

332
00:25:36.125 --> 00:25:40.628
say an ALU or, or a CPU chip or
something like that.

333
00:25:40.628 --> 00:25:42.764
And, and say, yeah, it works correctly.

334
00:25:42.764 --> 00:25:46.816
You know, it's we, we have to do it in,

335
00:25:46.816 --> 00:25:50.588
in a far more systematic and planned way.

336
00:25:50.588 --> 00:25:52.760
So is there a way to do it?

337
00:25:52.760 --> 00:25:54.512
Well, you bet.

338
00:25:54.512 --> 00:25:56.567
And that's,
that's what we're going to do next.

339
00:25:56.567 --> 00:26:00.339
In particular,
we can carry out the simulation with yet

340
00:26:00.339 --> 00:26:03.719
another tool which is
called a compare file.

341
00:26:03.719 --> 00:26:05.704
So here's an example of a compare file.

342
00:26:05.704 --> 00:26:08.759
It looks exactly like an output file.

343
00:26:08.759 --> 00:26:14.419
And in fact, in its previous incarnation,
the compare file was a,

344
00:26:14.419 --> 00:26:18.607
a, an output file of
a well-behaving Xor chips.

345
00:26:18.607 --> 00:26:22.447
So someone, and
we'll talk about this someone momentarily,

346
00:26:22.447 --> 00:26:25.422
someone has written an Xor chip correctly.

347
00:26:25.422 --> 00:26:28.708
Ran it thru the simulator,
generated an output file.

348
00:26:28.708 --> 00:26:31.587
Renamed it compare file and gave it us.

349
00:26:31.587 --> 00:26:35.428
And said, now you go and build your
chip and, and compare it to what I did.

350
00:26:35.428 --> 00:26:40.640
So basically, we can take the compare
file and load it into the simulator and

351
00:26:40.640 --> 00:26:45.456
then start to do the simulator as
the simulation as we did before.

352
00:26:45.456 --> 00:26:50.572
And now, in each step of the simulation,
whenever we output a set

353
00:26:50.572 --> 00:26:56.245
of selected pin values,
the simulator will compare the output

354
00:26:56.245 --> 00:27:00.726
set of values to the respective
line in the compare file.

355
00:27:00.726 --> 00:27:04.743
And if the two lines will
not agree with each other.

356
00:27:04.743 --> 00:27:08.411
The simulator will not
throw a comparison error.

357
00:27:08.411 --> 00:27:13.495
So this gives us that ability to not
only record the outputs of the chip,

358
00:27:13.495 --> 00:27:16.561
but also compare them to desired results.

359
00:27:16.561 --> 00:27:20.438
So you probably asked yourself once again,

360
00:27:20.438 --> 00:27:25.362
how do we generate these
compare files to begin with?

361
00:27:25.362 --> 00:27:25.930
Right?

362
00:27:25.930 --> 00:27:30.040
Well, we,
we could have left it as as a mystery, but

363
00:27:30.040 --> 00:27:35.114
there is no need to to
leave anything unexplained.

364
00:27:35.114 --> 00:27:36.193
So here's how we do it.

365
00:27:36.193 --> 00:27:40.349
We do it using something
called behavioral simulation.

366
00:27:40.349 --> 00:27:46.014
In particular,
consider this Xor gate that we saw before.

367
00:27:46.014 --> 00:27:52.353
And let us assume, once again that
this implementation is correct and

368
00:27:52.353 --> 00:27:57.035
we put it into the simulator
along with the script.

369
00:27:57.035 --> 00:28:02.886
We run it, we generate results and
then we simply rename it to be Xor.cmp and

370
00:28:02.886 --> 00:28:06.686
it becomes the official
compare file of this shape.

371
00:28:06.686 --> 00:28:09.336
So what is special about this slide,
didn't, didn't you say,

372
00:28:09.336 --> 00:28:10.889
everything that we said here before.

373
00:28:10.889 --> 00:28:14.969
Well, we did, but
there's one detail which is, which is

374
00:28:16.629 --> 00:28:22.232
remarkably interesting in this in
this notion of behavioral simulation.

375
00:28:22.232 --> 00:28:27.328
And, and the thing which is
interesting is that the chip

376
00:28:27.328 --> 00:28:33.412
logic can be implemented in any
way that the designer wishes.

377
00:28:33.412 --> 00:28:39.680
So we can write this chip logic in Java or
some other high-level language.

378
00:28:39.680 --> 00:28:41.666
We can run the program.

379
00:28:41.666 --> 00:28:45.805
We can generate an output file and
then once again,

380
00:28:45.805 --> 00:28:48.283
supply it as, as a compare file.

381
00:28:48.283 --> 00:28:53.521
So this technique of
writing gate logic using or

382
00:28:53.521 --> 00:28:57.920
implementing gate logic
using high-level language,

383
00:28:57.920 --> 00:29:00.444
gives you the ability to plan and

384
00:29:00.444 --> 00:29:06.522
test your hardware before you even write
a single line of HDL code, which is,

385
00:29:06.522 --> 00:29:11.787
you know quite sophisticated
way to do things.

386
00:29:11.787 --> 00:29:15.710
So we, you know,
we can do everything in a high-level and

387
00:29:15.710 --> 00:29:20.114
only once the overall design
of our machine works properly,

388
00:29:20.114 --> 00:29:24.857
we can begin to implement each
chip at the time in in HDL.

389
00:29:24.857 --> 00:29:26.134
All right.

390
00:29:26.134 --> 00:29:31.301
So this has been the notion of behavioral
simulation and I want to go on and

391
00:29:31.301 --> 00:29:36.089
talk about how we actually carry
out hardware construction projects.

392
00:29:36.089 --> 00:29:40.718
So the cast of characters in any
hardware construction project

393
00:29:40.718 --> 00:29:45.713
consists of several players of which,
I would like talk about two.

394
00:29:45.713 --> 00:29:48.232
First, we have the system architect.

395
00:29:48.232 --> 00:29:52.447
Now the system architect is,
is the person who is told, you know,

396
00:29:52.447 --> 00:29:58.242
go build a chip that supports a certain
function of a digit, digital camera or

397
00:29:58.242 --> 00:30:03.852
something like that or go build a chip
that monitors a certain medical device.

398
00:30:03.852 --> 00:30:09.719
So the architect has the exact sort of
user-level specifications of the chip and

399
00:30:09.719 --> 00:30:14.525
and the other member in the team
is a developer or, you know,

400
00:30:14.525 --> 00:30:19.088
more than one developer or
more than one architects and together,

401
00:30:19.088 --> 00:30:21.231
they have to design this chip.

402
00:30:21.231 --> 00:30:22.591
So how do they do it?

403
00:30:22.591 --> 00:30:31.064
Well, the system architect looks at the
overall desired operation of of the chip.

404
00:30:31.064 --> 00:30:36.724
And then he or she makes some decisions
about how to break this overall

405
00:30:36.724 --> 00:30:44.347
behavior into a set of smaller chips if
you will or sort of lower-level chips.

406
00:30:44.347 --> 00:30:47.876
And then for each one of these chips,
the architect,

407
00:30:47.876 --> 00:30:52.739
the architect creates a chip API,
which consists of the name of the chip,

408
00:30:52.739 --> 00:30:55.965
the names of its input and output pins.

409
00:30:55.965 --> 00:30:58.972
A test script and a compare file.

410
00:30:58.972 --> 00:31:03.574
Now, all these things are prepared
by the system architect who,

411
00:31:03.574 --> 00:31:08.878
you know, may, may or may not have some
people to help him or her in his work.

412
00:31:08.878 --> 00:31:11.824
And finally, given these resources,

413
00:31:11.824 --> 00:31:15.495
the developers can actually go out and
build the chip.

414
00:31:15.495 --> 00:31:18.232
So the architecture can do
behavioral simulation or

415
00:31:18.232 --> 00:31:22.971
they can do whatever they want in order to
test that everything fits together nicely.

416
00:31:22.971 --> 00:31:28.858
And at some point, the developers
actually build this thing using HDL.

417
00:31:28.858 --> 00:31:34.368
So, once again, that's,
that's an example of well

418
00:31:34.368 --> 00:31:40.258
planned modular design and gives
another example of divide and conquer.

419
00:31:40.258 --> 00:31:43.492
You know,
taking something very complicated and

420
00:31:43.492 --> 00:31:48.503
breaking into something more, you know,
a set of more manageable modules.

421
00:31:48.503 --> 00:31:53.574
Each of which can be created and
tested in isolation.

422
00:31:53.574 --> 00:31:58.252
So for example, the HEC computer I
could've told you something like go

423
00:31:58.252 --> 00:32:02.803
build yourself a computer and
actually that's what we do in this course.

424
00:32:02.803 --> 00:32:08.695
But we split this job into
the construction of something like 30,

425
00:32:08.695 --> 00:32:15.371
you know 30 different shapes that
together comprise the HEC chip set.

426
00:32:15.371 --> 00:32:18.923
So we, Norm and I, the course instructors,

427
00:32:18.923 --> 00:32:22.382
we play the role of
the system architects and

428
00:32:22.382 --> 00:32:27.635
you guys are playing the roles of
the actual hardware developers.

429
00:32:27.635 --> 00:32:29.321
All right.

430
00:32:29.321 --> 00:32:34.878
So the developer's view,
your view of a particular chip.

431
00:32:34.878 --> 00:32:38.187
You know, when we tell you to
build a chip, here's what you get.

432
00:32:38.187 --> 00:32:43.192
You're going to get a stub file
that contains the documentation

433
00:32:43.192 --> 00:32:48.021
of the chip that you have to build,
along with its interface.

434
00:32:48.021 --> 00:32:53.257
You're also going to get a test
script that we have written for you.

435
00:32:53.257 --> 00:32:57.305
You're going to get a compare file and
then, you know,

436
00:32:57.305 --> 00:33:02.217
taken together, what you've
basically got is everything that you

437
00:33:02.217 --> 00:33:06.717
need in order to number one,
understand the interface.

438
00:33:06.717 --> 00:33:10.537
Understand what the chip is supposed
to do, the compare file and

439
00:33:10.537 --> 00:33:13.381
we'll also tell you how
we are going to test it.

440
00:33:13.381 --> 00:33:13.915
All right.

441
00:33:13.915 --> 00:33:16.318
So what do you do with
all these resources?

442
00:33:16.318 --> 00:33:21.495
Well what you have to do is write
the missing implementation.

443
00:33:21.495 --> 00:33:26.821
The missing implementation is the HDL
code that should actually drive this

444
00:33:26.821 --> 00:33:28.101
entire show.

445
00:33:28.101 --> 00:33:34.800
So that's exactly what we're
going to do in unit 1.7.

446
00:33:34.800 --> 00:33:38.121
But before we go onto this unit,

447
00:33:38.121 --> 00:33:44.085
we also have to say a few things about
Multi-Bit Buses, which is a gap that

448
00:33:44.085 --> 00:33:49.650
we still have to close in in the general
description of HDL programming.